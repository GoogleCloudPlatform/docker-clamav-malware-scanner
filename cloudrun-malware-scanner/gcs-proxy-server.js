/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
// eslint-disable-next-line no-unused-vars
const {Config, readAndVerifyConfig} = require('./config.js');
const httpProxy = require('http-proxy');

const TOKEN_REFRESH_THRESHOLD_MILLIS = 60000;

const googleAuth = new GoogleAuth();


// access token for GCS requests - will be refreshed shortly before it expires
let accessToken;
let accessTokenRefreshTimeout;
let clamCvdMirrorBucket = 'uninitialized';

/**
 * Check to see when access token expires and refresh it just before.
 * This is required because proxy requires access token to be available
 * synchronously, but getAccessToken() is async.
 * So a 'current' access token needs to be available.
 */
async function accessTokenRefresh() {
  if (accessTokenRefreshTimeout) {
    clearTimeout(accessTokenRefreshTimeout);
    accessTokenRefreshTimeout = null;
  }

  const client = await googleAuth.getClient();
  if (!client.credentials?.expiry_date ||
      client.credentials.expiry_date <=
          new Date().getTime() + TOKEN_REFRESH_THRESHOLD_MILLIS) {
    accessToken = await googleAuth.getAccessToken();
    logger.info(`Refreshed Access token; expires at ${
      new Date(client.credentials.expiry_date).toISOString()}`);
  }
  const nextCheckDate =
      new Date(client.credentials.expiry_date - TOKEN_REFRESH_THRESHOLD_MILLIS);
  logger.debug(
      `Next access token refresh check at ${nextCheckDate.toISOString()}`);
  accessTokenRefreshTimeout = setTimeout(
      accessTokenRefresh, nextCheckDate.getTime() - new Date().getTime());
}

/**
 * Handle any internal proxy errors by returning a 500
 *
 * @param {!Error} err
 * @param {!IncomingMessage} req The request payload
 * @param {!ServerResponse} res The HTTP response object
 */
function handleProxyError(err, req, res) {
  logger.error(
      `Failed to proxy to GCS for path ${req.url}, returning code 500: ${err}`);
  res.writeHead(500, {
    'Content-Type': 'text/plain',
  });
  res.end(`Failed to proxy to GCS: internal error\n`);
}

/**
 * Handle proxy requests - check path, and add Authorization header.
 *
 * @param {!Request} proxyReq
 * @param {!IncomingMessage} req The request payload
 * @param {!ServerResponse} res The HTTP response object
 */
function handleProxyReq(proxyReq, req, res) {
  if (proxyReq.path.startsWith('/' + clamCvdMirrorBucket + '/')) {
    logger.info(`Proxying request for ${proxyReq.path} to GCS`);
    proxyReq.setHeader('Authorization', 'Bearer ' + accessToken);
  } else {
    logger.error(`Denying Proxy request for ${proxyReq.path} to GCS - 403`);
    res.writeHead(403, {
      'Content-Type': 'text/plain',
    });
    res.end('Failed to proxy to GCS - unauthorzied path: status 403\n');
  }
}

/**
 * Set up a reverse proxy to add authentication to HTTP requests from
 * freshclam and proxy it to the GCS API
 */
async function setupGcsReverseProxy() {
  const proxy = httpProxy.createProxyServer({
    target: 'https://storage.googleapis.com/',
    changeOrigin: true,
    autoRewrite: true,
    secure: true,
    ws: false,
  });

  proxy.on('error', handleProxyError);
  proxy.on('proxyReq', handleProxyReq);

  const PROXY_PORT = process.env.PROXY_PORT || 8888;

  proxy.listen(PROXY_PORT, 'localhost');
  logger.info(`GCS authenticating reverse proxy listenting on port ${
    PROXY_PORT} for requests to ${clamCvdMirrorBucket}`);
}

/**
 * Perform async setup and start the app.
 *
 * @async
 */
async function run() {
  let configFile;
  if (process.argv.length >= 3) {
    configFile = process.argv[2];
  } else {
    configFile = './config.json';
  }

  /** @type {Config} */
  const config = await readAndVerifyConfig(configFile);

  clamCvdMirrorBucket = config.ClamCvdMirrorBucket;

  await accessTokenRefresh();
  await setupGcsReverseProxy(config.ClamCvdMirrorBucket);
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
