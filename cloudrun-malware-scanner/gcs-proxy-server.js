/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
// eslint-disable-next-line no-unused-vars
const {Config, readAndVerifyConfig} = require('./config.js');
const httpProxy = require('http-proxy');

const googleAuth = new GoogleAuth();

// access token for GCS requests - will be refreshed every 50 mins
let accessToken;
const ACCESS_TOKEN_REFRESH_INTERVAL = 50 * 60 * 1000;

/**
 * Set up a reverse proxy to add authentication to HTTP requests from
 * freshclam and proxy it to the GCS API
 *
 * @param {string} clamCvdMirrorBucket
 */
async function setupGcsReverseProxy(clamCvdMirrorBucket) {
  // Get an OAuth2 access token and refresh it every 50mins.
  accessToken = await googleAuth.getAccessToken();

  setInterval(async () => {
    logger.info(`Refreshing Oauth2 Access Token for GCS proxy.`);
    accessToken = await googleAuth.getAccessToken();
  }, ACCESS_TOKEN_REFRESH_INTERVAL);

  const proxy = httpProxy.createProxyServer({
    target: 'https://storage.googleapis.com/',
    changeOrigin: true,
    autoRewrite: true,
    secure: true,
    ws: false,
  });

  // Error handling...
  proxy.on('error', function(err, req, res) {
    let statusCode = 500;
    if (res && res.statusCode && res.statusCode != 200) {
      statusCode = res.statusCode;
    }
    logger.error(`Failed to proxy to GCS for path ${req.url}, returning code ${
      statusCode}:  ${err}`);
    res.writeHead(statusCode, {
      'Content-Type': 'text/plain',
    });
    res.end(`Failed to proxy to GCS: status ${statusCode}\n`);
  });

  // Add auth header/
  proxy.on('proxyReq', function(proxyReq, req, res) {
    if (proxyReq.path.startsWith('/' + clamCvdMirrorBucket + '/')) {
      logger.info(`Proxying request for ${proxyReq.path} to GCS`);
      proxyReq.setHeader('Authorization', 'Bearer ' + accessToken);
    } else {
      logger.error(
          `Denying Proxy request for ${proxyReq.path} to GCS - invalid path`);
      res.writeHead(404, {
        'Content-Type': 'text/plain',
      });
      res.end('Failed to proxy to GCS - invalid path: status 404\n');
    }
  });

  const PROXY_PORT = process.env.PROXY_PORT || 8888;

  proxy.listen(PROXY_PORT, 'localhost');
  logger.info(
      `GCS authenticating reverse proxy listenting on port ${PROXY_PORT}`);
}

/**
 * Perform async setup and start the app.
 *
 * @async
 */
async function run() {
  let configFile;
  if (process.argv.length >= 3) {
    configFile = process.argv[2];
  } else {
    configFile = './config.json';
  }

  /** @type {Config} */
  const config = await readAndVerifyConfig(configFile);

  await setupGcsReverseProxy(config.ClamCvdMirrorBucket);
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
