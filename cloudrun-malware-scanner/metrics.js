/*
* Copyright 2021 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
const {globalStats, MeasureUnit, AggregationType, TagMap} =
    require('@opencensus/core');
const {StackdriverStatsExporter} = require('@opencensus/exporter-stackdriver');
const {logger} = require('./logger.js');
const METRIC_TYPE_ROOT = 'malware-scanning/';
const METRICS = {};
const TAGS = {
  sourceBucket: {name: 'source_bucket'},
  destinationBucket: {name: 'destination_bucket'},
  clamVersion: {name: 'clam_version'},
  cloudRunRevision: {name: 'cloud_run_revision'},
  cvdUpdateStatus: {name: 'cvd_update_status'},
};
const METRIC_EXPORT_INTERVAL = process.env.EXPORT_INTERVAL || 60;

/**
 * Writes a scan failed metric.
 * @param {string} sourceBucket
 */
function writeScanFailedMetric(sourceBucket) {
  const tags = new TagMap();
  if (sourceBucket) {
    tags.set(TAGS.sourceBucket, {value: sourceBucket});
    tags.set(TAGS.destinationBucket, {value: sourceBucket});
  }
  tags.set(TAGS.cloudRunRevision, {value: process.env.K_REVISION});
  globalStats.record([{measure: METRICS.scansFailed, value: 1}], tags);
}

/**
 * Writes metrics when a clean file is scanned
 * @param {string} sourceBucket
 * @param {string} destinationBucket
 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanCleanMetric(sourceBucket, destinationBucket, fileSize,
    scanDuration, clamVersion) {
  writeScanCompletedMetric_(METRICS.cleanFiles, sourceBucket, destinationBucket,
      fileSize, scanDuration, clamVersion);
}

/**
 * Writes metrics when an infected file is scanned
 * @param {string} sourceBucket
 * @param {string} destinationBucket
 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanInfectedMetric(sourceBucket, destinationBucket, fileSize,
    scanDuration, clamVersion) {
  writeScanCompletedMetric_(METRICS.infectedFiles, sourceBucket,
      destinationBucket, fileSize, scanDuration,
      clamVersion);
}
/**
 * Writes metrics for completed scans
 * @private
 * @param {!Object} measure
 * @param {string} sourceBucket
 * @param {string} destinationBucket
 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanCompletedMetric_(measure, sourceBucket, destinationBucket,
    fileSize, scanDuration, clamVersion) {
  const tags = new TagMap();
  tags.set(TAGS.sourceBucket, {value: sourceBucket});
  tags.set(TAGS.destinationBucket, {value: destinationBucket});
  tags.set(TAGS.clamVersion, {value: clamVersion});
  tags.set(TAGS.cloudRunRevision, {value: process.env.K_REVISION});
  globalStats.record(
      [
        {measure: measure, value: 1},
        {measure: METRICS.bytesScanned, value: fileSize},
        {measure: METRICS.scanDuration, value: scanDuration},
      ],
      tags);
}

/**
 * Writes metrics when a CVD Mirror Update occurs.
 *
 * @param {boolean} success
 * @param {boolean} isUpdated
 */
function writeCvdMirrorUpdatedMetric(success, isUpdated) {
  const tags = new TagMap();
  tags.set(TAGS.cloudRunRevision, {value: process.env.K_REVISION});
  tags.set(TAGS.cvdUpdateStatus,
      {value: (
       success ? (
        isUpdated ? 'SUCCESS_UPDATED' : 'SUCCESS_NO_UPDATES' ) :
      'FAILURE' )});
  globalStats.record(
      [{measure: METRICS.cvdUpdates, value: 1}],
      tags);
}

/**
 * Initialize cloud monitoring and set up metrics descriptions
 * @param {string} projectId
 */
async function initMetrics(projectId) {
  if (!projectId) {
    throw Error('Unable to proceed without a Project ID');
  }

  const exporter = new StackdriverStatsExporter({
    projectId: projectId,
    period: METRIC_EXPORT_INTERVAL * 1000,
  });
  globalStats.registerExporter(exporter);

  const fileScanTags = [
    TAGS.clamVersion,
    TAGS.cloudRunRevision,
    TAGS.sourceBucket,
    TAGS.destinationBucket,
  ];

  METRICS.cleanFiles = globalStats.createMeasureInt64(
      METRIC_TYPE_ROOT + 'clean-files', MeasureUnit.UNIT,
      'Number of clean files processed');

  const cleanFilesView =
      globalStats.createView(METRICS.cleanFiles.name,
          METRICS.cleanFiles, AggregationType.COUNT, fileScanTags,
          'Number of files scanned that were found ' +
                                 'to be clean of malware at the time of scan');
  globalStats.registerView(cleanFilesView);

  METRICS.infectedFiles = globalStats.createMeasureInt64(
      METRIC_TYPE_ROOT + 'infected-files', MeasureUnit.UNIT,
      'Number of infected files processed');

  const infectedFilesView = globalStats.createView(
      METRICS.infectedFiles.name, METRICS.infectedFiles,
      AggregationType.COUNT, fileScanTags,
      'Number of files scanned that were found ' +
          'to contain malware at the time of scan');
  globalStats.registerView(infectedFilesView);

  METRICS.scansFailed = globalStats.createMeasureInt64(
      METRIC_TYPE_ROOT + 'scans-failed', MeasureUnit.UNIT,
      'Number of failed scan requests');

  const failedScansView = globalStats.createView(
      METRICS.scansFailed.name, METRICS.scansFailed,
      AggregationType.COUNT, fileScanTags,
      'Number of malware scan requests which failed');
  globalStats.registerView(failedScansView);

  METRICS.bytesScanned = globalStats.createMeasureInt64(
      METRIC_TYPE_ROOT + 'bytes-scanned', MeasureUnit.BYTE,
      'Number of bytes processed');

  const bytesScannedView = globalStats.createView(
      METRICS.bytesScanned.name, METRICS.bytesScanned,
      AggregationType.SUM, fileScanTags, 'Total number of bytes scanned');
  globalStats.registerView(bytesScannedView);

  METRICS.scanDuration = globalStats.createMeasureDouble(
      METRIC_TYPE_ROOT + 'scan-duration', MeasureUnit.MS,
      'The scan duration in milliseconds');
  const scanDurationView = globalStats.createView(
      METRICS.scanDuration.name, METRICS.scanDuration,
      AggregationType.DISTRIBUTION, fileScanTags,
      'Duration spent scanning files',
      // Bucket Boundaries in ms
      [
        0,
        50,
        100,
        200,
        500,
        1000,
        2000,
        5000,
        10000,
        20000,
        50000,
        100000,
        200000,
      ]);
  globalStats.registerView(scanDurationView);

  METRICS.cvdUpdates = globalStats.createMeasureInt64(
      METRIC_TYPE_ROOT + 'cvd-mirror-updates', MeasureUnit.UNIT,
      'Number of CVD mirror Update Checks performed');

  const cvdUpdatesView = globalStats.createView(
      METRICS.cvdUpdates.name, METRICS.cvdUpdates,
      AggregationType.COUNT,
      [TAGS.cloudRunRevision, TAGS.cvdUpdateStatus],
      'Number of CVD mirror update checks performed with their status');
  globalStats.registerView(cvdUpdatesView);

  logger.info(
      `Metrics initialized for ${METRIC_TYPE_ROOT} on project ${projectId}`);
}

exports.writeScanFailed = writeScanFailedMetric;
exports.writeScanClean = writeScanCleanMetric;
exports.writeScanInfected = writeScanInfectedMetric;
exports.writeCvdMirrorUpdated = writeCvdMirrorUpdatedMetric;
exports.init = initMetrics;
