/*
* Copyright 2021 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
const process = require('node:process');

const {
  MeterProvider,
  PeriodicExportingMetricReader,
} = require('@opentelemetry/sdk-metrics');
const {Resource} = require('@opentelemetry/resources');
const {
  MetricExporter: GcpMetricExporter,
} = require('@google-cloud/opentelemetry-cloud-monitoring-exporter');
const {GcpDetectorSync} = require('@google-cloud/opentelemetry-resource-util');
const Semconv = require('@opentelemetry/semantic-conventions');
const {version: packageVersion} = require('./package.json');

const {logger} = require('./logger.js');
const METRIC_TYPE_ROOT = 'malware-scanning/';
const OpenTelemetryApi = require('@opentelemetry/api');

/**
 * @typedef {{
 *    [x: string]: string,
 * }} CounterAttributes
 */
/** @type {CounterAttributes} */
const RESOURCE_ATTRIBUTES = {
  [Semconv.SEMRESATTRS_SERVICE_NAMESPACE]: 'googlecloudplatform',
  [Semconv.SEMRESATTRS_SERVICE_NAME]: 'gcs-malware-scanning',
  [Semconv.SEMRESATTRS_SERVICE_VERSION]: packageVersion,
};

const COUNTERS_PREFIX =
  RESOURCE_ATTRIBUTES[Semconv.SEMRESATTRS_SERVICE_NAMESPACE] +
  '/' +
  RESOURCE_ATTRIBUTES[Semconv.SEMRESATTRS_SERVICE_NAME] +
  '/';

/** @enum{string} */
const COUNTER_NAMES = {
  cleanFiles: 'clean-files',
  infectedFiles: 'infected-files',
  scansFailed: 'scans-failed',
  bytesScanned: 'bytes-scanned',
  scanDuration: 'scan-duration',
  cvdUpdates: 'cvd-mirror-updates',
};

const COUNTER_ATTRIBUTE_NAMES = {
  sourceBucket: 'source_bucket',
  destinationBucket: 'destination_bucket',
  clamVersion: 'clam_version',
  cloudRunRevision: 'cloud_run_revision',
  cvdUpdateStatus: 'cvd_update_status',
};

/**
 * Global counters object, populated by createCounters.
 *
 * @type {Map<
 *    COUNTER_NAMES,
 *    {
 *      cumulative?: OpenTelemetryApi.Counter,
 *      histogram?: OpenTelemetryApi.Histogram
 *    }
 *  >} counter Name to counter instance
 */
const COUNTERS = new Map();

const METRIC_EXPORT_INTERVAL = parseInt(
  process.env.EXPORT_INTERVAL || '20',
  10,
);

/**
 * Wrapper class for OpenTelemetry DiagLogger to convert to Bunyan log levels
 *
 * @extends {OpenTelemetryApi.DiagLogger}
 */
class DiagToBunyanLogger {
  /** @constructor */
  constructor() {
    // In some cases where errors may be expected, we want to be able to supress
    // them.
    this.suppressErrors = false;
  }

  /**
   * @param {string} message
   * @param {any[]} args
   */
  verbose(message, ...args) {
    logger.trace('otel: ' + message, args);
  }

  /**
   * @param {string} message
   * @param {any[]} args
   */
  debug(message, ...args) {
    logger.debug('otel: ' + message, args);
  }
  /**
   * @param {string} message
   * @param {any[]} args
   */
  info(message, ...args) {
    logger.info('otel: ' + message, args);
  }
  /**
   * @param {string} message
   * @param {any[]} args
   */
  warn(message, ...args) {
    logger.warn('otel: ' + message, args);
  }
  /**
   * @param {string} message
   * @param {any[]} args
   */
  error(message, ...args) {
    if (!this.suppressErrors) {
      logger.error('otel: ' + message, args);
    }
  }
}

OpenTelemetryApi.default.diag.setLogger(new DiagToBunyanLogger(), {
  logLevel: OpenTelemetryApi.DiagLogLevel.INFO,
  suppressOverrideMessage: true,
});

/**
 * Writes a scan failed metric.
 * @param {string?} sourceBucket
 */
function writeScanFailedMetric(sourceBucket) {
  const attrs = {
    [COUNTER_ATTRIBUTE_NAMES.cloudRunRevision]:
      process.env.K_REVISION || 'no-revision',
  };
  if (sourceBucket) {
    attrs[COUNTER_ATTRIBUTE_NAMES.sourceBucket] = sourceBucket;
    attrs[COUNTER_ATTRIBUTE_NAMES.destinationBucket] = sourceBucket;
  }
  COUNTERS.get(COUNTER_NAMES.scansFailed)?.cumulative?.add(1, attrs);
}

/**
 * Writes metrics when a clean file is scanned
 * @param {string} sourceBucket
 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanCleanMetric(
  sourceBucket,
  fileSize,
  scanDuration,
  clamVersion,
) {
  writeScanCompletedMetric_(
    COUNTER_NAMES.cleanFiles,
    sourceBucket,
    fileSize,
    scanDuration,
    clamVersion,
  );
}

/**
 * Writes metrics when an infected file is scanned
 * @param {string} sourceBucket
 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanInfectedMetric(
  sourceBucket,
  fileSize,
  scanDuration,
  clamVersion,
) {
  writeScanCompletedMetric_(
    COUNTER_NAMES.infectedFiles,
    sourceBucket,
    fileSize,
    scanDuration,
    clamVersion,
  );
}
/**
 * Writes metrics for completed scans
 * @private
 * @param {string} counterName
 * @param {string} sourceBucket

 * @param {number} fileSize
 * @param {number} scanDuration
 * @param {string} clamVersion
 */
function writeScanCompletedMetric_(
  counterName,
  sourceBucket,
  fileSize,
  scanDuration,
  clamVersion,
) {
  const attrs = {
    [COUNTER_ATTRIBUTE_NAMES.sourceBucket]: sourceBucket,
    [COUNTER_ATTRIBUTE_NAMES.clamVersion]: clamVersion,
    [COUNTER_ATTRIBUTE_NAMES.cloudRunRevision]:
      process.env.K_REVISION || 'no-revision',
  };

  const counter = COUNTERS.get(counterName);
  if (!counter?.cumulative) {
    throw new Error('Unknown counter: ' + counterName);
  }
  counter.cumulative.add(1, attrs);

  COUNTERS.get('bytes-scanned')?.cumulative?.add(fileSize, attrs);
  COUNTERS.get(COUNTER_NAMES.scanDuration)?.histogram?.record(
    scanDuration,
    attrs,
  );
}

/**
 * Writes metrics when a CVD Mirror Update occurs.
 *
 * @param {boolean} success
 * @param {boolean} isUpdated
 */
function writeCvdMirrorUpdatedMetric(success, isUpdated) {
  COUNTERS.get(COUNTER_NAMES.cvdUpdates)?.cumulative?.add(1, {
    [COUNTER_ATTRIBUTE_NAMES.cloudRunRevision]:
      process.env.K_REVISION || 'no-revision',
    [COUNTER_ATTRIBUTE_NAMES.cvdUpdateStatus]: success
      ? isUpdated
        ? 'SUCCESS_UPDATED'
        : 'SUCCESS_NO_UPDATES'
      : 'FAILURE',
  });
}

/**
 * Initialize cloud monitoring and set up metrics descriptions
 * @param {string} projectId
 */
async function initMetrics(projectId) {
  if (!projectId) {
    throw Error('Unable to proceed without a Project ID');
  }

  logger.debug('initializing metrics');

  const resources = new GcpDetectorSync()
    .detect()
    .merge(new Resource(RESOURCE_ATTRIBUTES));

  const meterProvider = new MeterProvider({
    resource: resources,
    readers: [
      new PeriodicExportingMetricReader({
        exportIntervalMillis: METRIC_EXPORT_INTERVAL,
        exportTimeoutMillis: METRIC_EXPORT_INTERVAL,
        exporter: new GcpMetricExporter({prefix: 'workload.googleapis.com'}),
      }),
    ],
  });

  const meter = meterProvider.getMeter(COUNTERS_PREFIX);

  COUNTERS.set(COUNTER_NAMES.cleanFiles, {
    cumulative: meter.createCounter(
      COUNTERS_PREFIX + COUNTER_NAMES.cleanFiles,
      {
        description:
          'Number of files scanned that were found to be clean of malware at the time of scan',
      },
    ),
  });

  COUNTERS.set(COUNTER_NAMES.infectedFiles, {
    cumulative: meter.createCounter(
      COUNTERS_PREFIX + COUNTER_NAMES.infectedFiles,
      {
        description:
          'Number of files scanned that were found to contain malware at the time of scan',
      },
    ),
  });

  COUNTERS.set(COUNTER_NAMES.scansFailed, {
    cumulative: meter.createCounter(
      COUNTERS_PREFIX + COUNTER_NAMES.scansFailed,
      {
        description: 'Number of malware scan requests which failed',
      },
    ),
  });

  COUNTERS.set(COUNTER_NAMES.bytesScanned, {
    cumulative: meter.createCounter(COUNTERS_PREFIX + 'bytes-scanned', {
      description: 'Total number of bytes scanned',
      unit: 'By',
    }),
  });

  COUNTERS.set(COUNTER_NAMES.scanDuration, {
    histogram: meter.createHistogram(
      COUNTERS_PREFIX + COUNTER_NAMES.scanDuration,
      {
        description: 'Duration spent scanning files',
        unit: 'ms',
        advice: {
          explicitBucketBoundaries: [
            0, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000,
            200000,
          ],
        },
      },
    ),
  });

  COUNTERS.set(COUNTER_NAMES.cvdUpdates, {
    cumulative: meter.createCounter(
      COUNTERS_PREFIX + COUNTER_NAMES.cvdUpdates,
      {
        description:
          'Number of CVD mirror update checks performed with their status',
      },
    ),
  });

  logger.info(
    `Metrics initialized for ${METRIC_TYPE_ROOT} on project ${projectId}`,
  );
}

exports.writeScanFailed = writeScanFailedMetric;
exports.writeScanClean = writeScanCleanMetric;
exports.writeScanInfected = writeScanInfectedMetric;
exports.writeCvdMirrorUpdated = writeCvdMirrorUpdatedMetric;
exports.init = initMetrics;
