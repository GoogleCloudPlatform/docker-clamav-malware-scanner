/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const process = require('node:process');
// @ts-ignore -- TS7016: Could not find a declaration file
const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const metrics = require('./metrics.js');
const util = require('node:util');
const execFile = util.promisify(require('node:child_process').execFile);
const {setTimeout} = require('timers/promises');
const {readAndVerifyConfig} = require('./config.js');

/** @typedef {import('./config.js').Config} Config */
/** @typedef {import('express').Request} Request */
/** @typedef {import('express').Response} Response */

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;

// 10 min timeout for scanning.
const CLAMD_TIMEOUT = 600000;

// Note: MAX_FILE_SIZE limits the size of files which are sent to th
// ClamAV Daemon.
//
// ClamAV itself has internal limits, which apply both to the total file
// size, and to the size of compressed files inside file containers.
// These are set in the clamd.conf file by bootstrap.sh
//
// Note scanning a 500MiB file can take 5 minutes, so ensure timeout is
// large enough.
const MAX_FILE_SIZE = 500000000; // 500MiB

/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 *
 * @type {Config}
 */
const BUCKET_CONFIG = {
  ClamCvdMirrorBucket: '',
};

// Create Clients.
const app = express();
app.use(express.json());
/** @type {any} */
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage({
  userAgent: `cloud-solutions/${pkgJson.name}-usage-v${pkgJson.version}`,
});
const googleAuth = new GoogleAuth();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * For command line testing, use
 *
 * curl -d '{"kind": "storage#object","name":"test_file", "bucket": "BUCKET_NAME" }' -H "Content-Type: application/json" http://localhost:8080
 */
app.post('/', async (req, res) => {
  // Sanity check required values.
  switch (req.body.kind) {
    case 'storage#object':
      await handleGcsObject(req, res);
      break;
    case 'schedule#cvd_update':
      await handleCvdUpdate(req, res);
      break;
    default:
      handleErrorResponse(
        res,
        200,
        `${JSON.stringify(req.body)} is not supported` +
          '(kind must be storage#object or schedule#cvd_update',
      );
      break;
  }
});

/**
 * Handle a POST with a GCS object payload.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleGcsObject(req, res) {
  const file = req.body;
  try {
    if (!file?.name) {
      handleErrorResponse(res, 200, `file name not specified in ${file}`);
      return;
    }
    if (!file?.bucket) {
      handleErrorResponse(res, 200, `bucket name not specified in ${file}`);
      return;
    }
    const fileSize = parseInt(file.size);
    if (fileSize > MAX_FILE_SIZE) {
      handleErrorResponse(
        res,
        200,
        `file gs://${file.bucket}/${file.name} too large for scanning at ${fileSize} bytes`,
        file.bucket,
      );
      return;
    }

    const gcsFile = storage.bucket(file.bucket).file(file.name);
    // File.exists() returns a FileExistsResponse, which is a list with a
    // single value.
    if (!(await gcsFile.exists())[0]) {
      // Warn but return successful to client.
      logger.warn(
        `Ignoring no longer existing file: gs://${file.bucket}/${file.name}`,
      );
      res.json({status: 'deleted'});
      return;
    }

    const clamdVersion = await getClamVersion();
    logger.info(
      `Scan request for gs://${file.bucket}/${file.name}, (${fileSize} bytes) scanning with clam ${clamdVersion}`,
    );
    const startTime = Date.now();
    const readStream = await gcsFile.createReadStream();
    let result;
    try {
      result = await scanner.scanStream(readStream, CLAMD_TIMEOUT);
    } finally {
      // Ensure stream is destroyed in all situations to prevent any
      // resource leaks.
      readStream.destroy();
    }
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      logger.info(
        `Scan status for gs://${file.bucket}/${file.name}: CLEAN (${fileSize} bytes in ${scanDuration} ms)`,
      );
      metrics.writeScanClean(file.bucket, fileSize, scanDuration, clamdVersion);

      // Respond to API client.
      res.json({status: 'clean', clam_version: clamdVersion});
    } else {
      logger.warn(
        `Scan status for gs://${file.bucket}/${file.name}: INFECTED ${result} (${fileSize} bytes in ${scanDuration} ms)`,
      );
      metrics.writeScanInfected(
        file.bucket,
        fileSize,
        scanDuration,
        clamdVersion,
      );

      // Respond to API client.
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
    }
  } catch (e) {
    logger.error(
      {err: e},
      `Exception when processing gs://${file.bucket}/${file.name}: ${e}`,
    );

    // A 500 will cause Pubsub/EventArc to retry the event.
    let statusCode = 500;

    const errcode = /** @type {import('@google-cloud/storage').ApiError} */ (e)
      .code;
    if (errcode && [403, 404].includes(errcode)) {
      // Permission denied/file not found can be raised by the stream reading
      // and by the object move. They cannot be retried, so respond
      // with success, but log the error.
      statusCode = 200;
    }

    handleErrorResponse(
      res,
      statusCode,
      `gs://${file.bucket}/${file.name}: ${e}`,
      file.bucket,
    );
  }
}

/**
 * Triggers a update check on the CVD Mirror GCS bucket.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleCvdUpdate(req, res) {
  try {
    logger.info('Starting CVD Mirror update');
    const result = await execFile('./updateCvdMirror.sh', [
      BUCKET_CONFIG.ClamCvdMirrorBucket,
    ]);
    logger.info('CVD Mirror update check complete. output:\n' + result.stdout);
    // look for updated versions in output by looking for
    // "updated (version: " from freshclam output.
    const newVersions = result.stdout
      .split('\n')
      // Look for lines beginning with Downloaded
      .filter((line) => line.indexOf('Downloaded') >= 0);
    for (const version of newVersions) {
      logger.info(`CVD Mirror updated: ${version}`);
    }
    res.json({
      status: 'CvdUpdateComplete',
      updated: newVersions.length > 0,
    });
    metrics.writeCvdMirrorUpdated(true, newVersions.length > 0);
  } catch (err) {
    const e = /** @type {any} */ (err);
    logger.error(
      {err: e},
      `Failure when running updateCvdMirror: ${e}\nstdout: ${e.stdout}\nstderr: \n${e.stderr}`,
    );
    metrics.writeCvdMirrorUpdated(false, false);
    res.status(500).json({message: e.message, status: 'CvdUpdateError'});
  }
}

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res
    .status(200)
    .type('text/plain')
    .send(
      `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}

${pkgJson.description}

`,
    );
});

/**
 * Respond with an error and log the message
 *
 * Note: any non-successful status codes will cause the caller (PubSub/Eventarc)
 * to retry sending the event, so use 200 for non-retryable errors.
 *
 * @param {Response} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string?=} unscannedBucket
 */
function handleErrorResponse(
  res,
  statusCode,
  errorMessage,
  unscannedBucket = null,
) {
  logger.error(`Error processing request: ${errorMessage}`);
  res.status(statusCode).json({message: errorMessage, status: 'error'});
  metrics.writeScanFailed(unscannedBucket);
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replace('\x00', '');
}

/**
 *  Wait up to 5 mins for ClamD to respond
 */
async function waitForClamD() {
  const timeoutMins = 10;
  const endTime = Date.now() + timeoutMins * 60 * 1000;

  logger.info('Waiting for Clamd');
  while (Date.now() < endTime) {
    try {
      const version = await getClamVersion();
      logger.info(`Clamd started with version ${version}`);
      return;
    } catch (e) {
      logger.warn(`Waiting for clamd to start: ${e}`);
    }
    await setTimeout(10000);
  }
  logger.fatal(`Clamd not started after ${timeoutMins} mins`);
  process.exit(1);
}

/**
 * Perform async setup and start the app.
 *
 * @async
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // Metrics needs project ID, so get it from GoogleAuth
    projectId = await googleAuth.getProjectId();
  }
  await metrics.init(projectId);

  let configFile;
  if (process.argv.length >= 3) {
    configFile = process.argv[2];
  } else {
    configFile = './config.json';
  }
  const config = await readAndVerifyConfig(configFile);

  Object.assign(BUCKET_CONFIG, config);

  await waitForClamD();

  app.listen(PORT, () => {
    logger.info(
      `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`,
    );
  });
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
