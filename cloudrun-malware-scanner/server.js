/*
* Copyright 2019 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {ApiError} = require('@google-cloud/common');
const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const metrics = require('./metrics.js');

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;
const MAX_FILE_SIZE = 5000000000; // 5GiB

/**
 * Configuration object.
 *
 * Values are read from the environment variable CONFIG_FILE (which specifies a
 * JSON file to read the config from) or single-bucket config variables: 
 * UNSCANNED_BUCKET, CLEAN_BUCKET and QUARANTINED_BUCKET.
 * See {@link readAndVerifyConfig}.
 *
 * @type {{
 *    buckets: Array<
 *      {
 *        unscanned: string,
 *        clean: string,
 *        quarantined: string
 *       }>
 *  }}
 */
const BUCKET_CONFIG = {
  buckets: [],
};

// Create Clients.
const app = express();
app.use(express.json());
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
app.post('/', async (req, res) => {
  logger.debug('Request body: %o', req.body);

  // Sanity check required values.
  if (!req.body || req.body.kind !== 'storage#object') {
    handleErrorResponse(res, 400, `${req.body} is not a GCS Storage Object`);
    return;
  }

  const file = req.body;
  try {
    if (!file.name) {
      handleErrorResponse(res, 400, `file name not specified in ${file}`);
      return;
    }
    if (!file.bucket) {
      handleErrorResponse(res, 400, `bucket name not specified in ${file}`);
      return;
    }
    if (file.size > MAX_FILE_SIZE) {
      handleErrorResponse(
          res, 413,
          `file gs://${file.bucket}/${file.name} too large for scanning at ${
            file.size} bytes`,
          file.bucket);
      return;
    }
    const config =
        BUCKET_CONFIG.buckets.filter((c) => c.unscanned === file.bucket)[0];
    if (!config) {
      handleErrorResponse(res, 200,
          `Bucket name - ${file.bucket} not in config`);
      return;
    }

    const gcsFile = storage.bucket(file.bucket).file(file.name);
    if (! (await gcsFile.exists())) {
      handleErrorResponse(res, 200,
          `File: gs://${file.bucket}/${file.name} does not exist`);
      return;
    }

    const clamdVersion = await getClamVersion();
    logger.info(`Scan request for gs://${file.bucket}/${file.name}, (${
      file.size} bytes) scanning with clam ${clamdVersion}`);
    const startTime = Date.now();
    const readStream = await gcsFile.createReadStream();
    const result = await scanner.scanStream(readStream);
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      // Move document to the bucket that holds clean documents
      await moveProcessedFile(file.name, true, config);

      // Log scan outcome
      logger.info(`Scan status for gs://${file.bucket}/${file.name}: CLEAN (${
        file.size} bytes in ${scanDuration} ms)`);

      // Respond to API client
      res.json({status: 'clean', clam_version: clamdVersion});
      metrics.writeScanClean(config.unscanned, config.clean, file.size,
          scanDuration, clamdVersion);
    } else {
      // Move document to the bucket that holds infected documents
      await moveProcessedFile(file.name, false, config);

      // Log scan outcome for document
      logger.warn(`Scan status for gs://${file.bucket}/${
        file.name}: INFECTED ${result} (${
        file.size} bytes in ${scanDuration} ms)`);

      // Respond to API client
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
      metrics.writeScanInfected(config.unscanned, config.quarantined, file.size,
          scanDuration, clamdVersion);
    }
  } catch (e) {
    logger.error(
        {err: e},
        `Exception when processing gs://${file.bucket}/${file.name}: %s`,
        e.message);
    let statusCode = 500;
    if ((e instanceof ApiError) && e.code) {
      statusCode = e.code; // ApiError codes match HTTP status codes
    }
    handleErrorResponse(res, statusCode,
        `gs://${file.bucket}/${file.name}: ${e.message}`,
        file.bucket);
  }
});

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res.status(200)
      .type('text/plain')
      .send(
          `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}      

${pkgJson.description}
(Responds to POST requests containing a GCS object only)

`);
});

/**
 * Respond with an error and log the message
 * @param {Object} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string=} unscannedBucket
 */
function handleErrorResponse(res, statusCode, errorMessage,
    unscannedBucket = null) {
  logger.error(`Error processing request: ${errorMessage}`);
  res.status(statusCode).json({message: errorMessage, status: 'error'});
  metrics.writeScanFailed(unscannedBucket);
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replaceAll('\x00', '');
}

/**
 * Move the file to the appropriate bucket.
 * @param {string} filename
 * @param {boolean} isClean
 * @param {!Object} config
 */
async function moveProcessedFile(filename, isClean, config) {
  const srcfile = storage.bucket(config.unscanned).file(filename);
  const destinationBucketName =
      isClean ? `gs://${config.clean}` : `gs://${config.quarantined}`;
  const destinationBucket = storage.bucket(destinationBucketName);
  await srcfile.move(destinationBucket);
}

/**
 * Read configuration from process environmental variables.
 *
 * Can be CONFIG_FILE for a JSON file, or single-bucket config
 * variables: UNSCANNED_BUCKET, CLEAN_BUCKET and
 * QUARANTINED_BUCKET
 */
async function readAndVerifyConfig() {
  if (process.env.CONFIG_FILE) {
    if (!process.env.CONFIG_FILE.endsWith('.json')) {
      throw new Error(`CONFIG_FILE="${
        process.env.CONFIG_FILE}" should end with ".json"`);
    }
    try {
      const envConfig = require(process.env.CONFIG_FILE);
      BUCKET_CONFIG.buckets = envConfig.buckets;
    } catch (e) {
      logger.fatal(
          {err: e},
          `Unable to read JSON file from CONFIG_FILE="${
            process.env.CONFIG_FILE}"`);
      throw new Error(`Invalid configuration CONFIG_FILE="${
        process.env.CONFIG_FILE}"`);
    }
  } else if (process.env.UNSCANNED_BUCKET && process.env.CLEAN_BUCKET &&
      process.env.QUARANTINED_BUCKET) {
    // Simple config for single-bucket scanning.
    BUCKET_CONFIG.buckets = [{
      unscanned: process.env.UNSCANNED_BUCKET,
      clean: process.env.CLEAN_BUCKET,
      quarantined: process.env.QUARANTINED_BUCKET,
    }];
  }

  if (BUCKET_CONFIG.buckets.length === 0) {
    logger.fatal(`No buckets configured for scanning`);
    throw new Error('No buckets configured');
  }

  logger.info("BUCKET_CONFIG: "+JSON.stringify(BUCKET_CONFIG, null, 2));

  // Check buckets are specified and exist.
  let success = true;
  for (let x = 0; x < BUCKET_CONFIG.buckets.length; x++) {
    for (const bucket of ['unscanned', 'clean', 'quarantined']) {
      if (!BUCKET_CONFIG.buckets[x][bucket]) {
        logger.fatal(
            `Error in bucket config #${x}: no "${bucket}" bucket defined`);
        success = false;
      }
      if (!(await storage.bucket(BUCKET_CONFIG.buckets[x][bucket]).exists())) {
        logger.fatal(`Error in bucket config[${x}]: "${bucket}" bucket: ${
          BUCKET_CONFIG.buckets[x][bucket]} does not exist`);
        success = false;
      }
    }
  }
  if (!success) {
    throw new Error('Invalid configuration');
  }
}

/**
 * Perform async setup and start the app.
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // get default project ID from GoogleAuth
    projectId = await (new GoogleAuth().getProjectId());
  }
  await metrics.init(projectId);
  await readAndVerifyConfig();

  app.listen(PORT, () => {
    logger.info(
        `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`);
  });
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
