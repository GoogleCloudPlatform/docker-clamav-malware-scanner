/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const metrics = require('./metrics.js');
const util = require('node:util');
const execFile = util.promisify(require('node:child_process').execFile);
const {setTimeout} = require('timers/promises');
// eslint-disable-next-line no-unused-vars
const {Config, readAndVerifyConfig} = require('./config.js');

const PORT = process.env.PORT || 8080;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;

// 10 min timeout for scanning.
const CLAMD_TIMEOUT = 600000;

// Note: MAX_FILE_SIZE limits the size of files which are sent to th
// ClamAV Daemon.
//
// ClamAV itself has internal limits, which apply both to the total file
// size, and to the size of compressed files inside file containers.
// These are set in the clamd.conf file by bootstrap.sh
//
// Note scanning a 500MiB file can take 5 minutes, so ensure timeout is
// large enough.
const MAX_FILE_SIZE = 500000000; // 500MiB

/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 *
 * @type {Config}
 */
const BUCKET_CONFIG = {
  buckets: [],
  ClamCvdMirrorBucket: '',
};

// Create Clients.
const app = express();
app.use(express.json());
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage({userAgent: `cloud-solutions/${
  pkgJson.name}-usage-v${pkgJson.version}`});
const googleAuth = new GoogleAuth();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * For command line testing, use
 *
 * curl -d '{"kind": "storage#object","name":"test_file", "bucket": "BUCKET_NAME" }' -H "Content-Type: application/json" http://localhost:8080
 *
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
app.post('/', async (req, res) => {
  // Sanity check required values.
  switch (req.body.kind) {
    case 'storage#object':
      await handleGcsObject(req, res);
      break;
    case 'schedule#cvd_update':
      await handleCvdUpdate(req, res);
      break;
    default:
      handleErrorResponse(
          res,
          200,
          `${JSON.stringify(req.body)} is not supported` +
          '(kind must be storage#object or schedule#cvd_update');
      break;
  }
});


/**
 * Handle a POST with a GCS object payload.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleGcsObject(req, res) {
  const file = req.body;
  try {
    if (!file.name) {
      handleErrorResponse(res, 200, `file name not specified in ${file}`);
      return;
    }
    if (!file.bucket) {
      handleErrorResponse(res, 200, `bucket name not specified in ${file}`);
      return;
    }
    const fileSize = parseInt(file.size);
    if ( fileSize > MAX_FILE_SIZE) {
      handleErrorResponse(
          res, 200,
          `file gs://${file.bucket}/${file.name} too large for scanning at ${
            fileSize} bytes`,
          file.bucket);
      return;
    }
    const config =
        BUCKET_CONFIG.buckets.filter((c) => c.unscanned === file.bucket)[0];
    if (!config) {
      handleErrorResponse(res, 200,
          `Bucket name - ${file.bucket} not in config`);
      return;
    }

    const gcsFile = storage.bucket(file.bucket).file(file.name);
    // File.exists() returns a FileExistsResponse, which is a list with a
    // single value.
    if (! (await gcsFile.exists())[0]) {
      // Warn but return successful to client.
      logger.warn(`Ignoring no longer existing file: gs://${file.bucket}/${file.name}`);
      res.json({status: 'deleted'});
      return;
    }

    const clamdVersion = await getClamVersion();
    logger.info(`Scan request for gs://${file.bucket}/${file.name}, (${
      fileSize} bytes) scanning with clam ${clamdVersion}`);
    const startTime = Date.now();
    const readStream = await gcsFile.createReadStream();
    let result;
    try {
      result = await scanner.scanStream(readStream, CLAMD_TIMEOUT);
    } finally {
      // Ensure stream is destroyed in all situations to prevent any
      // resource leaks.
      readStream.destroy();
    }
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      logger.info(`Scan status for gs://${file.bucket}/${file.name}: CLEAN (${
        fileSize} bytes in ${scanDuration} ms)`);
      metrics.writeScanClean(config.unscanned, config.clean, fileSize,
          scanDuration, clamdVersion);

      // Move document to the bucket that holds clean documents. This can
      // fail due to permissions or if the file has been deleted.
      await moveProcessedFile(file.name, true, config);

      // Respond to API client.
      res.json({status: 'clean', clam_version: clamdVersion});
    } else {
      logger.warn(`Scan status for gs://${file.bucket}/${
        file.name}: INFECTED ${result} (${
        fileSize} bytes in ${scanDuration} ms)`);
      metrics.writeScanInfected(config.unscanned, config.quarantined, fileSize,
          scanDuration, clamdVersion);

      // Move document to the bucket that holds infected documents. This can
      // fail due to permissions or if the file has been deleted.
      await moveProcessedFile(file.name, false, config);

      // Respond to API client.
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
    }
  } catch (e) {
    logger.error(
        {err: e},
        `Exception when processing gs://${file.bucket}/${file.name}: %s`,
        e.message);

    // A 500 will cause Pubsub/EventArc to retry the event.
    let statusCode=500;

    if ([403, 404].includes(e.code) ) {
      // Permission denied/file not found can be raised by the stream reading
      // and by the object move. They cannot be retried, so respond
      // with success, but log the error.
      statusCode=200;
    }

    handleErrorResponse(res, statusCode,
        `gs://${file.bucket}/${file.name}: ${e.message}`,
        file.bucket);
  }
}


/**
 * Triggers a update check on the CVD Mirror GCS bucket.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
async function handleCvdUpdate(req, res) {
  try {
    logger.info('Starting CVD Mirror update');
    const result = await execFile(
        './updateCvdMirror.sh',
        [BUCKET_CONFIG.ClamCvdMirrorBucket],
        {stdio: ['ignore', 'inherit', 'inherit']});
    logger.info('CVD Mirror update check complete. output:\n'+result.stdout);
    // look for updated versions in output by looking for
    // "updated (version: " from freshclam output.
    const newVersions = (result.stdout
        .split('\n')
        // Look for lines beginning with Downloaded
        .filter((line) => line.indexOf('Downloaded') >= 0));
    for (const version of newVersions) {
      logger.info(`CVD Mirror updated: ${version}`);
    }
    res.json({
      status: 'CvdUpdateComplete',
      updated: newVersions.length > 0});
    metrics.writeCvdMirrorUpdated(true, newVersions.length > 0);
  } catch (e) {
    logger.error(
        {err: e.message},
        `Failure when running updateCvdMirror: %s\ncode: %s, stderr:\n%s`,
        e.message,
        e.code,
        e.stderr);
    metrics.writeCvdMirrorUpdated(false, false);
    res.status(500).json({message: e.message, status: 'CvdUpdateError'});
  }
}


/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res.status(200)
      .type('text/plain')
      .send(
          `${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}

${pkgJson.description}

`);
});

/**
 * Respond with an error and log the message
 *
 * Note: any non-successful status codes will cause the caller (PubSub/Eventarc)
 * to retry sending the event, so use 200 for non-retryable errors.
 *
 * @param {Object} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string=} unscannedBucket
 */
function handleErrorResponse(res, statusCode, errorMessage,
    unscannedBucket = /** @type {string} */ null) {
  logger.error(`Error processing request: ${errorMessage}`);
  res.status(statusCode).json({message: errorMessage, status: 'error'});
  metrics.writeScanFailed(unscannedBucket);
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replace('\x00', '');
}

/**
 * Move the file to the appropriate bucket.
 * @async
 * @param {string} filename
 * @param {boolean} isClean
 * @param {!Object} config
 */
async function moveProcessedFile(filename, isClean, config) {
  const srcfile = storage.bucket(config.unscanned).file(filename);
  const destinationBucketName =
      isClean ? `gs://${config.clean}` : `gs://${config.quarantined}`;
  const destinationBucket = storage.bucket(destinationBucketName);
  await srcfile.move(destinationBucket);
}

/**
 *  Wait up to 5 mins for ClamD to respond
 */
async function waitForClamD() {
  const timeoutMins = 10;
  const endTime=Date.now() + timeoutMins*60*1000;

  logger.info('Waiting for Clamd');
  while (Date.now() < endTime) {
    try {
      const version = await getClamVersion();
      logger.info(`Clamd started with version ${version}`);
      return;
    } catch (e) {
      logger.warn(`Waiting for clamd to start: ${e.message}`);
    }
    await setTimeout(10000);
  }
  logger.fatal(`Clamd not started after ${timeoutMins} mins`);
  process.exit(1);
}

/**
 * Perform async setup and start the app.
 *
 * @async
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // Metrics needs project ID, so get it from GoogleAuth
    projectId = await (googleAuth.getProjectId());
  }
  await metrics.init(projectId);

  let configFile;
  if (process.argv.length >= 3) {
    configFile = process.argv[2];
  } else {
    configFile = './config.json';
  }
  const config = await readAndVerifyConfig(configFile);

  Object.assign(BUCKET_CONFIG, config);

  await waitForClamD();

  app.listen(PORT, () => {
    logger.info(
        `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`);
  });
}

// Start the service, exiting on error.
run().catch((e) => {
  logger.fatal(e);
  logger.fatal('Exiting');
  process.exit(1);
});
