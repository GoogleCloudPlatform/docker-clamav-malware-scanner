/*
* Copyright 2019 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const clamd = require('clamdjs');
const express = require('express');
const {Storage} = require('@google-cloud/storage');
const {ApiError} = require('@google-cloud/common');
const {GoogleAuth} = require('google-auth-library');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');
const metrics = require('./metrics.js');

const PORT = process.env.PORT || 8080;
const CLOUD_STORAGE_BUCKET = process.env.UNSCANNED_BUCKET;
const CLEAN_BUCKET = process.env.CLEAN_BUCKET;
const QUARANTINED_BUCKET = process.env.QUARANTINED_BUCKET;
const CLAMD_HOST = '127.0.0.1';
const CLAMD_PORT = 3310;
const MAX_FILE_SIZE = 5000000000; // 5GiB

// Create Clients.
const app = express();
app.use(express.json());
const scanner = clamd.createScanner(CLAMD_HOST, CLAMD_PORT);
const storage = new Storage();

/**
 * Route that is invoked by Cloud Run when a malware scan is requested
 * for a document uploaded to GCS.
 *
 * @param {!Request} req The request payload
 * @param {!Response} res The HTTP response object
 */
app.post('/', async (req, res) => {
  logger.debug('Request body: %o', req.body);

  // Sanity check required values.
  if (!req.body || req.body.kind !== 'storage#object') {
    handleErrorResponse(res, 400, `${req.body} is not a GCS Storage Object`);
    return;
  }

  const file = req.body;
  try {
    if (!file.name) {
      handleErrorResponse(res, 400, `file name not specified in ${file}`);
      return;
    }
    if (!file.bucket) {
      handleErrorResponse(res, 400, `bucket name not specified in ${file}`);
      return;
    }
    if (file.size > MAX_FILE_SIZE) {
      handleErrorResponse(
          res, 413,
          `file gs://${file.bucket}/${file.name} too large for scanning at ${
            file.size} bytes`,
          file.bucket);
      return;
    }
    if (file.bucket !== CLOUD_STORAGE_BUCKET) {
      handleErrorResponse(res, 403, `Incorrect bucket name - ${file.bucket}`);
      return;
    }

    const clamdVersion = await getClamVersion();
    logger.info(`Scan request for gs://${file.bucket}/${file.name}, (${
      file.size} bytes) scanning with clam ${clamdVersion}`);
    const startTime = Date.now();
    const readStream = await storage.bucket(CLOUD_STORAGE_BUCKET)
        .file(file.name)
        .createReadStream();
    const result = await scanner.scanStream(readStream);
    const scanDuration = Date.now() - startTime;

    if (clamd.isCleanReply(result)) {
      // Move document to the bucket that holds clean documents
      await moveProcessedFile(file.name, true);

      // Log scan outcome
      logger.info(`Scan status for gs://${file.bucket}/${file.name}: CLEAN (${
        file.size} bytes in ${scanDuration} ms)`);

      // Respond to API client
      res.json({status: 'clean', clam_version: clamdVersion});
      metrics.writeScanClean(CLOUD_STORAGE_BUCKET, CLEAN_BUCKET, file.size,
          scanDuration, clamdVersion);
    } else {
      // Move document to the bucket that holds infected documents
      await moveProcessedFile(file.name, false);

      // Log scan outcome for document
      logger.warn(`Scan status for ${(file.name)}: INFECTED ${result}`);

      // Respond to API client
      res.json({
        message: result,
        status: 'infected',
        result: result,
        clam_version: clamdVersion,
      });
      metrics.writeScanInfected(CLOUD_STORAGE_BUCKET, QUARANTINED_BUCKET,
          file.size, scanDuration, clamdVersion);
    }
  } catch (e) {
    logger.error(
        {err: e},
        `Exception when processing gs://${file.bucket}/${file.name}: %s`,
        e.message);
    let statusCode = 500;
    if ((e instanceof ApiError) && e.code) {
      statusCode = e.code; // ApiError codes match HTTP status codes
    }
    handleErrorResponse(res, statusCode,
        `gs://${file.bucket}/${file.name}: ${e.message}`,
        file.bucket);
  }
});

/**
 * Trivial handler for get requests which returns the clam version.
 *
 * Use:
 * curl -D - -H "Authorization: Bearer $(gcloud auth print-identity-token)"  \
     CLOUD_RUN_APP_URL
 * @param {!Request} req
 * @param {!Response} res
 */
app.get('/', async (req, res) => {
  res.status(200)
      .type('text/plain')
      .send(`${pkgJson.name} version ${pkgJson.version}
Using Clam AV version: ${await getClamVersion()}      

${pkgJson.description}
(Responds to POST requests containing a GCS object only)

`);
});

/**
 * Respond with an error and log the message
 * @param {Object} res response object
 * @param {number} statusCode
 * @param {string} errorMessage
 * @param {string=} unscannedBucket
 */
function handleErrorResponse(res, statusCode, errorMessage,
    unscannedBucket = null) {
  logger.error(`Error processing request: ${errorMessage}`);
  res.status(statusCode).json({message: errorMessage, status: 'error'});
  metrics.writeScanFailed(unscannedBucket);
}

/**
 * Wrapper to get a clean string with the version of CLAM.
 * @return {Promise<string>}
 */
async function getClamVersion() {
  return (await clamd.version(CLAMD_HOST, CLAMD_PORT)).replaceAll('\x00', '');
}

/**
 * Move the file to the appropriate bucket.
 * @param {string} filename
 * @param {boolean} isClean
 */
async function moveProcessedFile(filename, isClean) {
  const srcfile = storage.bucket(CLOUD_STORAGE_BUCKET).file(filename);
  const destinationBucketName =
      isClean ? `gs://${CLEAN_BUCKET}` : `gs://${QUARANTINED_BUCKET}`;
  const destinationBucket = storage.bucket(destinationBucketName);
  await srcfile.move(destinationBucket);
}

/**
 * Perform async setup and start the app.
 */
async function run() {
  let projectId = process.env.PROJECT_ID;
  if (!projectId) {
    // get default project ID from GoogleAuth
    projectId = await (new GoogleAuth().getProjectId());
  }
  await metrics.init(projectId);
  app.listen(PORT, () => {
    logger.info(
        `${pkgJson.name} version ${pkgJson.version} started on port ${PORT}`);
  });
}

// Start the service.
run().catch(console.error);
