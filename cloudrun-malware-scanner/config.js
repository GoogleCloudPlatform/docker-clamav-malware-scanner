/*
* Copyright 2022 Google LLC

* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at

*     https://www.apache.org/licenses/LICENSE-2.0

* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

const {Storage} = require('@google-cloud/storage');
const {logger} = require('./logger.js');
const pkgJson = require('./package.json');


/**
 * Configuration object.
 *
 * Values are read from the JSON configuration file.
 * See {@link readAndVerifyConfig}.
 *
 * @typedef {{
 *    buckets: Array<
 *      {
 *        unscanned: string,
 *        clean: string,
 *        quarantined: string
 *       }>,
 *    ClamCvdMirrorBucket: string
 *  }}
 */
const Config = null;

const storage = new Storage({userAgent: `cloud-solutions/${
  pkgJson.name}-usage-v${pkgJson.version}`});

/**
 * Read configuration from JSON configuration file, verify
 * and return a Config object
 *
 * @async
 * @param {string} configFile
 * @return {Config}
 */
async function readAndVerifyConfig(configFile) {
  logger.info(`Using configuration file: ${configFile}`);


  /** @type {Config} */
  let config;

  try {
    config = require(configFile);
    delete config.comments;
  } catch (e) {
    logger.fatal({err: e}, `Unable to read JSON file from ${configFile}`);
    throw new Error(`Invalid configuration ${configFile}`);
  }

  if (config.buckets.length === 0) {
    logger.fatal(`No buckets configured for scanning in ${configFile}`);
    throw new Error('No buckets configured');
  }

  logger.info('BUCKET_CONFIG: ' + JSON.stringify(config, null, 2));

  // Check buckets are specified and exist.
  let success = true;
  for (let x = 0; x < config.buckets.length; x++) {
    const buckets = config.buckets[x];
    for (const bucketType of ['unscanned', 'clean', 'quarantined']) {
      if (!(await checkBucketExists(
          buckets[bucketType], `config.buckets[${x}].${bucketType}`))) {
        success = false;
      }
    }
    if (buckets.unscanned === buckets.clean ||
        buckets.unscanned === buckets.quarantined ||
        buckets.clean === buckets.quarantined) {
      logger.fatal(
          `Error in ${configFile} buckets[${x}]: bucket names are not unique`);
      success = false;
    }
  }
  if (!(await checkBucketExists(
      config.ClamCvdMirrorBucket, 'ClamCvdMirrorBucket'))) {
    success = false;
  }

  if (!success) {
    throw new Error('Invalid configuration');
  }
  return config;
}


/**
 * Check that given bucket exists. Returns true on success
 *
 * @param {string} bucketName
 * @param {string} configName
 * @return {Promise<boolean>}
 */
async function checkBucketExists(bucketName, configName) {
  if (!bucketName) {
    logger.fatal(`Error in config: no "${configName}" bucket defined`);
    success = false;
  }
  // Check for bucket existence by listing files in bucket, will throw
  // an exception if the bucket is not readable.
  // This is used in place of Bucket.exists() to avoid the need for
  // Project/viewer permission.
  try {
    await storage.bucket(bucketName)
        .getFiles({maxResults: 1, prefix: 'zzz', autoPaginate: false});
    return true;
  } catch (e) {
    logger.fatal(`Error in config: cannot view files in "${configName}" : ${
      bucketName} : ${e.message}`);
    logger.debug({err: e});
    return false;
  }
}

exports.Config = Config;
exports.readAndVerifyConfig = readAndVerifyConfig;
